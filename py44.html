<!DOCTYPE html>
<html>
<head>
  <!-- Google tag (gtag.js) ここから-->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZW1B1EX70P"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-ZW1B1EX70P');
  </script>
  <!-- Google tag (gtag.js) ここまで-->
  

  <!-- reset CSS -->
  <link rel="styesheet" href="https://unpkg.com/ress/dist/ress.min.css">
  <!-- Lightbox2 CDN -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/lightbox2/2.7.1/css/lightbox.css" rel="stylesheet">
  <script src="https://code.jquery.com/jquery-1.12.4.min.js" type="text/javascript"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lightbox2/2.7.1/js/lightbox.min.js" type="text/javascript"></script>
  <!--MathJax-->
  <script src="./js/math-jax.js" type="text/javascript" charset="UTF-8"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <meta charset="UTF-8" />
  <link rel="icon" href="./img/favicon.ico" />
  <title>海城中学高等学校 情報科</title>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="./js/script.js" type="text/javascript" charset="UTF-8"></script>
  <link rel="stylesheet" type="text/css" href="./css/css.css">
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
  <header><!-- script_pages.js --></header>
  <!----COMMON HEADER END---->  
  
  <section>

    <article>
      <h2 id="headline_1">(1) 選択ソート（単純選択法）</h2>
      <h3> 選択ソート（単純選択法）とは</h3>
      <p><strong> 選択ソート（単純選択法）</strong>は、配列の中から最小の要素を見つけて、先頭に移動させることを繰り返すことでソートするアルゴリズムです。</p>
      
      <h3>手順</h3>
      <ol>
        <li>整列していない配列（リスト）を用意します。</li>
        <li>未整列の先頭の値を暫定の最小値とします。</li>
        <li>未整列の２番目から末尾までの最小値を探し、暫定の最小値よりも小さければ、未整列の先頭と交換します。</li>
        <li>未整列の先頭を整列済みにします。</li>
        <li><b>(2)</b>〜<b>(4)</b>を繰り返し、すべての値が整列済みになれば終了します。</li>
      </ol>
      
      
      <h3>デモンストレーション</h3>
      <div id="selection-sort" class="demo">
        <label for="arrayLength2">配列の長さ:</label>
        <input type="number" id="arrayLength2" class="arrayLength" value="8" min="2">
        <button onclick="initialize()">配列をリセット</button>
        <div class="container" id="arycontainer"></div>
        <div id="description" class="description"></div>
        <button onclick="nextStep()">次へ</button>
      </div>
      
      
      <h3>プログラム</h3>
      <p></p>
      <p>Colaboratoryのノートブックに書き写しながら、理解しましょう。</p>
      <pre class="python" data-title="選択ソート"><code>
        arr = [6, 3, 2, 0, 7, 1, 4, 5] # 元のリスト
        print(arr)    # ソート前を出力
        n = len(arr)

        print("------------------------")
                
        for i in range(n - 1):                # 未整列の左端を1つずつ後にずらしていく（繰り返しインデックスの変数をiとする）
          min_index = i                     # 暫定最小値の位置（初期値は未整列の先頭のインデックス=i）
          for j in range(i + 1, n):         # 未整列の２番目(i+1)から末尾まで繰り返す（繰り返しインデックスの変数をjとする）
            if arr[min_index] > arr[j]:   # 暫定最小値よりもj番目の値が小さければ、
              min_index = j             # 暫定最小値の位置をj番目とする
                            # この時点で、未整列の最小値がarr[min_index]と決まる
          tmp = arr[min_index]              # i番目(arr[i])と未整列の最小値(arr[min_index])を交換
          arr[min_index] = arr[i]
          arr[i] = tmp
          print(arr)                        # 途中経過を出力

        print("------------------------")
        print(arr)    # ソート後を出力
      </code></pre>
      <pre class="result"><code>
        [6, 3, 2, 0, 7, 1, 4, 5]
        ------------------------
        [0, 3, 2, 6, 7, 1, 4, 5]
        [0, 1, 2, 6, 7, 3, 4, 5]
        [0, 1, 2, 6, 7, 3, 4, 5]
        [0, 1, 2, 3, 7, 6, 4, 5]
        [0, 1, 2, 3, 4, 6, 7, 5]
        [0, 1, 2, 3, 4, 5, 7, 6]
        [0, 1, 2, 3, 4, 5, 6, 7]
        ------------------------
        [0, 1, 2, 3, 4, 5, 6, 7]
      </code></pre>
      
      <h5>関連項目</h5>

      <p>・<a href="./py41.html#search-minimum" target="_blank">4-1. リニアサーチ（線形探索法） 最小値探索のプログラム</a></p>
      <p>・<a href="./py43.html#swap-element" target="_blank">4-3. バブルソート（単純交換法） 配列内の要素の交換</a></p>
      

      <h3>このアルゴリズムの特徴</h3>
      <h4>比較回数</h4>
      <p>最初に、\(n-1\) 回の比較を行って、最小値を探します。次に、残りの未整列要素 \(n-2\) 個の最小値を探すために \(n-2\) 回の比較を行います。よって、</p>
      
      \[
        比較回数 = (n-1) + (n-2) + (n-3) + \cdots + 2 + 1 = \frac{1}{2}n(n-1)
      \]
      <p>となります。</p>
      
      <h4>交換回数</h4>
      <p>配列の各要素について、暫定最小値よりも未整列部分の最小値が小さい場合に、1回ずつ交換が行われます。よって、最大交換回数は \(n-1\) 回となります。</p>
      
      <h4>バブルソートとの比較</h4>
      <p>比較回数はどちらのアルゴリズムも同じ回数ですが、最大交換回数は選択ソートの方が小さくなりますので、バブルソートよりは少しだけ速くなります。しかし、どちらのアルゴリズムも高効率とはいえず、次ページ以降のアルゴリズムがよく用いられます（プログラミングの学習としては、バブルソートや選択ソートは最適です）。</p>
    
    
    
    
    
      <h3>練習問題</h3>
      <h4>問1</h4>
      <p id="question-sentence-q1"></p>
      <table id="sort-table-q1" class="table-toggle-cell"></table>
      
      <h4>問2</h4>
      <p id="question-sentence-q2"></p>
      <table id="sort-table-q2" class="table-toggle-cell"></table>
      
      <h4>問3</h4>
      <p id="question-sentence-q3"></p>
      <table id="sort-table-q3" class="table-toggle-cell"></table>

      <h4>問4</h4>
      <p id="question-sentence-q4"></p>
      <table id="sort-table-q4" class="table-toggle-cell"></table>
      
      
    </article>
  </section>
        


 

   <section id="questions"><!-- script_pages.js --></section>
<!-- COMMON FOOTER START -->
  <section id="next_page"><!-- script_pages.js --></section>

  <footer>Copyright(C) Kaijo Junior and Senior High School. All Rights Reserved.</footer>
  <script src="./js/pages.js" type="text/javascript" charset="UTF-8"></script>
  <script src="./js/script_pages.js" type="text/javascript" charset="UTF-8"></script>


  <script>    

    let divs = [];
    let minId = 0;
    let startId = 0;
    let step = 0;


    const container = document.getElementById("arycontainer");
    const description = document.getElementById("description");

    initialize();
    question_initialize();


    function initialize(){
      description.textContent = `選択ソートを開始します。`;
      let arrayLength = parseInt(document.getElementById("arrayLength2").value);

      divs = createDivs(container, arrayLength, true);

      minId = 0;
      startId = 0;
      step = 0;
    }

    function nextStep(){
      //選択ソート 次へ

      if(startId >= divs.length-1){
        divs[startId].classList.remove("swapped");
        divs[startId].classList.add("sorted");
        description.textContent = ` すべてが整列済みになり、並び替え完了です。`;
        return;
      }

      if(step%4==0){
        //startIdをハイライト
        divs[startId].classList.add("highlighted");
        description.textContent = ` 未整列の先頭を暫定の最小値とします。`;
      }else if(step%4==1){
        //startId〜最後までの最小値を探し、最小値をハイライト
        minId = findMin();
        divs[minId].classList.add("highlighted");
        description.textContent = ` 未整列の先頭よりあとの値の最小値を探します。`;
      }else if(step%4==2){
        //startIdと最小値を交換
        swap(startId, minId);
        description.textContent = ` 未整列の先頭と最小値を交換します。`;

      }else{
        //startIdをsortedに換え、startId++
        divs[startId].classList.remove("swapped");
        divs[minId].classList.remove("swapped");
        divs[startId].classList.add("sorted");
        description.textContent = ` 未整列の先頭を整列済みにします。`;
        startId++;
      }

      step++;
    }

    function findMin(){
      min = parseInt(divs[startId].textContent);
      k = startId;

      for(let i=startId;i<divs.length;i++){
        if(min > parseInt(divs[i].textContent)){
          min = parseInt(divs[i].textContent);
          k = i;
        }
      }

      return k;
    }

    function swap(i, j){
      [divs[i].textContent, divs[j].textContent] = [divs[j].textContent, divs[i].textContent];

      divs[i].classList.remove("highlighted");
      divs[j].classList.remove("highlighted");
      divs[i].classList.add("swapped");
      divs[j].classList.add("swapped");
    }

    function createDivs(container, arrayLength, shuffle = true){
      container.innerHTML = "";
      let aryNum = Array.from({ length: arrayLength }, (_, i) => i);

      if(shuffle){aryNum = shuffleArray(aryNum);}

      let aryDiv = [];

      for(let i=0;i<aryNum.length;i++){
        const div = document.createElement("div");
        div.classList.add("item");
        container.appendChild(div);

        const divValue = document.createElement("div");
        divValue.classList.add("divValue");
        divValue.textContent = aryNum[i];
        aryDiv.push(divValue);
        div.appendChild(divValue);

        const divIndex = document.createElement("div");
        divIndex.classList.add("divIndex");
        divIndex.textContent = i;
        div.appendChild(divIndex);
      }

      return aryDiv;
    }

      // 選択ソートの関数
      function selectionSort(arr) {
          const process = [arr.slice()];  // ソートの途中経過を保存
          let compareCount = 0;
          let swapCount = 0;

          for (let i = 0; i < arr.length - 1; i++) {
              let minIndex = i;
              for (let j = i + 1; j < arr.length; j++) {
                  compareCount++;
                  if (arr[j] < arr[minIndex]) {
                      minIndex = j;
                  }
              }

              if (minIndex !== i) {
                  // 交換
                  [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
                  swapCount++;
                  process.push(arr.slice()); // 途中経過を保存
              }
          }
          return { process, compareCount, swapCount };
      }

      // テーブルを更新する関数
      function updateTable(process, questionNumber, sortName) {
          const arr = process[0];

          // 問題文の更新
          const questionSentence = document.getElementById("question-sentence-" + questionNumber);
          questionSentence.innerHTML = `次の表は、配列<tt>arr = [${arr}]</tt>を${sortName}によって昇順に並び替える過程を表している。表中の空欄に適する数字を答えなさい。`;

          // テーブルのクリア
          const sortTable = document.getElementById("sort-table-" + questionNumber);
          sortTable.innerHTML = "";

          // テーブルヘッドの作成
          const thead = document.createElement("thead");
          const tableHeader = document.createElement("tr");
          const thInitial = document.createElement("th");
          thInitial.innerHTML = "＼";
          tableHeader.appendChild(thInitial);

          // 配列のインデックスをヘッダーに追加
          arr.forEach((_, i) => {
              const th = document.createElement("th");
              th.innerHTML = `<tt>${i}</tt>`;
              tableHeader.appendChild(th);
          });

          thead.appendChild(tableHeader);
          sortTable.appendChild(thead);

          // テーブルボディの作成
          const tbody = document.createElement("tbody");

          process.forEach((step, i) => {
              const row = document.createElement("tr");
              const stepTitle = document.createElement("th");

              if (i === 0) {
                  stepTitle.innerText = "初期値";
              } else {
                  stepTitle.innerText = `${i}回目`;
              }

              row.appendChild(stepTitle);

              // 配列の値を行に追加
              step.forEach(value => {
                  const td = document.createElement("td");
                  if (i === 0 || i === process.length - 1) {
                      td.innerText = value;
                  } else {
                      td.className = "transparent clickable";
                      td.innerText = value;
                  }
                  row.appendChild(td);
              });

              tbody.appendChild(row);
          });

          sortTable.appendChild(tbody);
      }

      // 初期化
      function question_initialize(){
          updateTable(createQuestionArray([3,7,9,5,1]), "q1", "選択ソート");
          updateTable(createQuestionRandomArray(6, 6), "q2", "選択ソート");
          updateTable(createQuestionRandomArray(7, 7), "q3", "選択ソート");
          updateTable(createQuestionRandomArray(10, 10), "q4", "選択ソート");
      }

      // 配列からソート過程を作成する関数
      function createQuestionArray(arr) {
          const result = selectionSort(arr.slice());   // ソート方法
          return result.process;
      }

      // ランダム配列を生成する関数
      function createQuestionRandomArray(arrLength, minSwapTimes) {
          const arr = Array.from({length: arrLength}, (_, i) => i);

          let process = []; // 初期化（空の配列として宣言）
          let compareCount = 0;
          let swapCount = 0;

          for(let i = 0; i < 500; i++){
              shuffleArray(arr);

              const result = selectionSort(arr.slice());   // ソート方法
              process = result.process;

              if(process.length >= minSwapTimes){
                  return process;
              }
          }
      }

      // 配列をシャッフルする関数 
    function shuffleArray(ary) {
      for (let i = (ary.length - 1); 0 < i; i--) {
        let r = Math.floor(Math.random() * (i + 1));
        [ary[i], ary[r]] = [ary[r], ary[i]];
      }
      return ary;
    }
  </script>
  
</body>
</html>

