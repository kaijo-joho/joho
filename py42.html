<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
	<style id="critical-colors">
	  html { color:#191919; color-scheme: light dark; background: transparent; }
	  @media (prefers-color-scheme: dark) {
	    html { color:#e6e6e6; color-scheme: dark light; background: transparent; }
	  }
	  body { background-color:#f3f3f3; }
	  @media (prefers-color-scheme: dark) {
	    body { background-color:#0b0b0b; }
	  }
	</style>
  <title>海城中学高等学校 情報科</title>
  <script defer src="./js/main.js"></script>
</head>
<body>
  
    
  
  <section>

    <article>
      <h2 id="headline_1">(1) バイナリサーチ（二分探索法）</h2>
      <h3>バイナリサーチ（二分探索法）とは</h3>
      <p><strong>バイナリサーチ（二分探索法）</strong>は、要素が昇順(または降順)に並んでいる配列に対して高速に探索できるアルゴリズムです。調べる範囲を半分に絞りながら探す方法なので、２つ（バイナリ）に分けて探索ことから、バイナリサーチといいます。</p>
      <h3>手順</h3>
      <p>昇順（または降順）に並んでいる配列に対して、次の操作をします。</p>
      <ol>
        <li>探索範囲(最初は全範囲)の左端の位置(<tt>left</tt>)と右端の位置(<tt>right</tt>)を決めます。</li>
        <li>探索範囲の中央の位置(<tt>mid</tt>)を求めます: <tt>mid = (left + right) // 2</tt>。</li>
        <li>中央値(<tt>arr[mid]</tt>)が探索値(<tt>x</tt>)と一致したら、中央の位置(<tt>mid</tt>)が探索値の位置となり、探索を終了します。</li>
        <li>中央値が探索値より小さければ(<tt>arr[mid] &lt; x</tt>)、中央の位置よりも左側にはより小さい値しかないので、左半分を調べる必要はなくなります。<br>
          よって、探索範囲を右半分にすればよいので、探索範囲の左端を中央の位置より１つ右にします(<tt>left = mid + 1</tt>)。</li>
        <li>中央値が探索値よりも大きければ(<tt>arr[mid] &gt; x</tt>)、中央の位置よりも右側にはより大きい値しかないので、右半分を調べる必要はなくなります。<br>
          よって、探索範囲を左半分にすればよいので、探索範囲の右端を中央の位置より１つ左にします(<tt>right = mid - 1</tt>)。</li>
        <li>探索範囲にデータが存在する間は、<b>(2)</b>〜<b>(5)</b>を繰り返します。</li>
      </ol>
      
      <h3>フローチャート</h3>
      <img src="img/search_binary.png" alt="バイナリサーチのフローチャート" class="image">
      
      <h3>デモンストレーション</h3>
      <div id="binary-search" class="demo">
        <label for="arrayLength2">配列の長さ:</label>
        <input type="number" id="arrayLength2" class="arrayLength" value="12" min="2" max="20">
        <label for="searchValueInput2">探索値:</label>
        <input type="number" id="searchValueInput2" class="arrayLength" value="6">
        <button onclick="initialize()">配列をリセット</button>

        <div class="container" id="arycontainer"></div>

        <div class="container" id="searchValuecontainer">
          <div class="item">
            <div class="divValue" id="searchValue"></div>
            <div class="divIndex">探索値</div>
          </div>
        </div>

        <div id="description" class="description"></div>

        <button onclick="nextStep()">次へ</button>
      </div>
      
      <h3>プログラム（基本）</h3>
      <p>上記の手順をプログラムに書くと、次のようになります。</p>
      <p>Colaboratoryのノートブックに書き写しながら、理解しましょう。</p>
      <pre class="python" data-title="バイナリサーチ"><code>
        arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
        print(arr)
        target = int(input("探索値:"))

        x = -1          # 探索値のインデックス番号（初期値: -1）
        n = len(arr)

        left = 0        # 探索範囲の左端の位置
        right = n - 1   # 探索範囲の右端の位置

        while left <= right:                # 探索範囲の左端と右端の間にデータがある限り繰り返す
          mid = (left + right) // 2       # 探索範囲の中央の位置
          if arr[mid] == target:          # 中央値＝探索値のとき
            x = mid                     # xに中央の位置を代入して終了
            break
          elif arr[mid] < target:         # 中央値＜探索値のとき、左端を中央の位置より１つ右に移動する
            left = mid + 1
          else:                           # 中央値＞探索値のとき、右端を中央の位置より１つ左に移動する
            right = mid - 1

        if x != -1:
          print(target, "のインデックス番号は", x)
        else:
          print(target, "は存在しません。")
      </code></pre>
      <pre class="result"><code>
        [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
        探索する数値:5    #5を入力した場合
        5 のインデックス番号は 2
      </code></pre>
      
<!--
      <h3>プログラム（def文）</h3>
      <p><b>def文</b>を用いてバイナリサーチを実行する部分を関数にまとめると、次のようになります。<b>binary_search関数</b>は配列<tt>arr</tt>と探索値<tt>target</tt>を引数として受け取り、<tt>target</tt>のインデックスを返します存在しない場合は<tt>-1</tt>を返します）。</p>
      <p>Colaboratoryのノートブックに書き写しながら、理解しましょう。</p>
      <pre class="python" data-title=""><code>def binary_search(arr, target):
  # binary_search関数： 
  #   配列arrと探索値targetを受け取り、探索値のインデックス番号を返す。
  #   探索値が存在しない場合は -1を返す。
  left, right = 0, len(arr) - 1

  while left <= right:
    mid = (left + right) // 2
    if arr[mid] == target:
      return mid  # targetのインデックスを返す
    elif arr[mid] < target:
      left = mid + 1
    else:
      right = mid - 1
  return -1  # targetが存在しない場合、-1を返す


arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
print(arr)
target = int(input("探索値:"))
x = binary_search(arr, target)  # binary_search関数の呼び出し

if x != -1:
  print(target, "のインデックス番号は", x)
else:
  print(target, "は存在しません。")</code></pre>   
      <pre class="result"><code>[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
探索値:10
10 は存在しません。</code></pre>

      
      <h3>メリットとデメリット</h3>
      <h4>メリット</h4>
      <p>処理速度が速い。</p>
      <h4>デメリット</h4>
      <p>データをあらかじめ昇順(または降順)にソート(並び替え)しておく必要がある。</p>
-->
      
      
      <h3>探索回数</h3>
      <p> \(n = 8\)の配列<tt>[0, 1, 2, 3, 4, 5, 6, 7]</tt>をバイナリサーチしたときに、各数字が見つかるときの探索回数は次の表の通りです。</p>
      <table>
        <tr>
          <th width="60px">探索回数</th>
          <th style="width:25px;">0</th>
          <th style="width:25px;">1</th>
          <th style="width:25px;">2</th>
          <th style="width:25px;">3</th>
          <th style="width:25px;">4</th>
          <th style="width:25px;">5</th>
          <th style="width:25px;">6</th>
          <th style="width:25px;">7</th>
        </tr>
        <tr>
          <th>1回目</th>
          <td></td>
          <td></td>
          <td></td>
          <td>3</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <th>2回目</th>
          <td></td>
          <td>1</td>
          <td></td>
          <td></td>
          <td></td>
          <td>5</td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <th>3回目</th>
          <td>0</td>
          <td></td>
          <td>2</td>
          <td></td>
          <td>4</td>
          <td></td>
          <td>6</td>
          <td></td>
        </tr>
        <tr>
          <th>4回目</th>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td>7</td>
        </tr>
      </table>


      <p>また、\(n = 15\)の配列<tt>[0, 1, 2, ･･･, 14]</tt>をバイナリサーチしたときに、各数字が見つかるときの探索回数は次の表の通りです。</p>
      <table>
        <tr>
          <th width="60px">探索回数</th>
          <th style="width:25px;">0</th>
          <th style="width:25px;">1</th>
          <th style="width:25px;">2</th>
          <th style="width:25px;">3</th>
          <th style="width:25px;">4</th>
          <th style="width:25px;">5</th>
          <th style="width:25px;">6</th>
          <th style="width:25px;">7</th>
          <th style="width:25px;">8</th>
          <th style="width:25px;">9</th>
          <th style="width:25px;">10</th>
          <th style="width:25px;">11</th>
          <th style="width:25px;">12</th>
          <th style="width:25px;">13</th>
          <th style="width:25px;">14</th>
        </tr>
        <tr>
          <th>1回目</th>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td>7</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <th>2回目</th>
          <td></td>
          <td></td>
          <td></td>
          <td>3</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td>11</td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <th>3回目</th>
          <td></td>
          <td>1</td>
          <td></td>
          <td></td>
          <td></td>
          <td>5</td>
          <td></td>
          <td></td>
          <td></td>
          <td>9</td>
          <td></td>
          <td></td>
          <td></td>
          <td>13</td>
          <td></td>
        </tr>
        <tr>
          <th>4回目</th>
          <td>0</td>
          <td></td>
          <td>2</td>
          <td></td>
          <td>4</td>
          <td></td>
          <td>6</td>
          <td></td>
          <td>8</td>
          <td></td>
          <td>10</td>
          <td></td>
          <td>12</td>
          <td></td>
          <td>14</td>
        </tr>
      </table>

      <p>また、\(n = 16\)の配列<tt>[0, 1, 2, ･･･, 15]</tt>では次の通りです。</p>
      <table>
        <tr>
          <th width="60px">探索回数</th>
          <th style="width:25px;">0</th>
          <th style="width:25px;">1</th>
          <th style="width:25px;">2</th>
          <th style="width:25px;">3</th>
          <th style="width:25px;">4</th>
          <th style="width:25px;">5</th>
          <th style="width:25px;">6</th>
          <th style="width:25px;">7</th>
          <th style="width:25px;">8</th>
          <th style="width:25px;">9</th>
          <th style="width:25px;">10</th>
          <th style="width:25px;">11</th>
          <th style="width:25px;">12</th>
          <th style="width:25px;">13</th>
          <th style="width:25px;">14</th>
          <th style="width:25px;">15</th>
        </tr>
        <tr>
          <th>1回目</th>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td>7</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <th>2回目</th>
          <td></td>
          <td></td>
          <td></td>
          <td>3</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td>11</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <th>3回目</th>
          <td></td>
          <td>1</td>
          <td></td>
          <td></td>
          <td></td>
          <td>5</td>
          <td></td>
          <td></td>
          <td></td>
          <td>9</td>
          <td></td>
          <td></td>
          <td></td>
          <td>13</td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <th>4回目</th>
          <td>0</td>
          <td></td>
          <td>2</td>
          <td></td>
          <td>4</td>
          <td></td>
          <td>6</td>
          <td></td>
          <td>8</td>
          <td></td>
          <td>10</td>
          <td></td>
          <td>12</td>
          <td></td>
          <td>14</td>
          <td></td>
        </tr>
        <tr>
          <th>5回目</th>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td>15</td>
        </tr>
      </table>
      
      <h4>最小探索回数</h4>
      <p><strong>最小探索回数</strong>は、探索値が中央にあった場合なので１回です。</p>
      
      <h4>最大探索回数</h4>
      <p><strong>最大探索回数</strong>は、上記の具体例からもわかるとおり、データ数を \(n\) 個とすると、\(2^x \leqq n &lt; 2^{x+1}\) のとき、最大探索回数は \(x+1\) 回と表せます。</p>
      <p>これを対数を用いて表すと \(x \leqq \log_2 n &lt; x+1\) となり、\(\log_2 n\) の整数部分が \(x\) となることから、ガウス記号を用いて \(x=[\log_2 n]\) と表すことができます。したがって、最大探索回数は \([\log_2 n]+1\) 回となります。</p>
      <p>※\(2^3 = 8 \) は、対数を用いると \(\log_2 8 = 3\) と表せます。</p>
      
      <h4>平均探索回数</h4>
      <p>バイナリサーチの平均探索回数を厳密に求めることは大変なので、次のように考えます。</p>
      <p>最大探索回数の1回前までで全データの半分以上を探索することができるので、平均探索回数は\([\log_2 n]\) 回となります。</p>
      
      <h3>最大探索回数の比較</h3>
      <p>リニアサーチとバイナリサーチの探索回数を比較すると、次のようになります。</p>
      <img src="./img/py41_001.png" class="screen_shot">
      <p>データ数が多くなっても、バイナリサーチはリニアサーチに比べてあまり増加しないことがわかります。バイナリサーチでは、データ数が２倍になっても、探索回数は１回増えるだけなので、効率がいい探索方法であることがわかります（ただし、データが昇順または降順に並んでいる必要があります）。</p>
      
    </article>
    <article>
      <h2 id="headline_4">練習問題</h2>
      <p>リニアサーチ（線形探索）とバイナリサーチ（二分探索）の探索効率の違いについて、次の各問いに答えなさい。
        ただし、はじめは自分の力のみで考えなさい（紙とペンのみ使用可）。
        その後、バイナリサーチは<strong>#実習 1-01</strong>のプログラムに探索回数を求める処理を追加して確かめなさい。</p>
      
      <p>連番の配列<tt>[0, 1, 2, ..., 15]</tt>を生成するには、次のように書きます。</p>
      <pre class="python" data-title=""><code>arr = list(range(16))</code></pre>
      
      <h3>問1</h3>
      <p>0以上の整数が昇順に並んだ \(n\) ＝16の配列<tt>[0, 1, 2, 3, ・・・, 15]</tt>について、次の探索値が見つかるまでの回数（探索回数）はいくつか。</p>
      
      <table class="table-toggle-cell">
        <tr>
          <th width="120px">探索値</th>
          <th style="width:50px;">0</th>
          <th style="width:50px;">1</th>
          <th style="width:50px;">3</th>
          <th style="width:50px;">6</th>
          <th style="width:50px;">7</th>
          <th style="width:50px;">8</th>
          <th style="width:50px;">9</th>
          <th style="width:50px;">12</th>
          <th style="width:50px;">15</th>
        </tr>
        <tr>
          <th>リニアサーチ</th>
          <td class="transparent clickable">1</td>
          <td class="transparent clickable">2</td>
          <td class="transparent clickable">4</td>
          <td class="transparent clickable">7</td>
          <td class="transparent clickable">8</td>
          <td class="transparent clickable">9</td>
          <td class="transparent clickable">10</td>
          <td class="transparent clickable">13</td>
          <td class="transparent clickable">16</td>
        </tr>
        <tr>
          <th>バイナリサーチ</th>
          <td class="transparent clickable">4</td>
          <td class="transparent clickable">3</td>
          <td class="transparent clickable">2</td>
          <td class="transparent clickable">4</td>
          <td class="transparent clickable">1</td>
          <td class="transparent clickable">4</td>
          <td class="transparent clickable">3</td>
          <td class="transparent clickable">4</td>
          <td class="transparent clickable">5</td>
        </tr>
      </table>
      
      <h3>問2</h3>
      <p>0以上の整数が昇順に並んだ \(n\) ＝256の配列<tt>[0, 1, 2, 3, ・・・, 255]</tt>について、次の探索値が見つかるまでの回数（探索回数）はいくつか。</p>
      
      <table class="table-toggle-cell">
        <tr>
          <th width="120px">探索値</th>
          <th style="width:50px;">0</th>
          <th style="width:50px;">1</th>
          <th style="width:50px;">7</th>
          <th style="width:50px;">127</th>
          <th style="width:50px;">128</th>
          <th style="width:50px;">129</th>
          <th style="width:50px;">195</th>
          <th style="width:50px;">221</th>
          <th style="width:50px;">255</th>
        </tr>
        <tr>
          <th>リニアサーチ</th>
          <td class="transparent clickable">1</td>
          <td class="transparent clickable">2</td>
          <td class="transparent clickable">8</td>
          <td class="transparent clickable">128</td>
          <td class="transparent clickable">129</td>
          <td class="transparent clickable">130</td>
          <td class="transparent clickable">196</td>
          <td class="transparent clickable">222</td>
          <td class="transparent clickable">256</td>
        </tr>
        <tr>
          <th>バイナリサーチ</th>
          <td class="transparent clickable">8</td>
          <td class="transparent clickable">7</td>
          <td class="transparent clickable">5</td>
          <td class="transparent clickable">1</td>
          <td class="transparent clickable">8</td>
          <td class="transparent clickable">7</td>
          <td class="transparent clickable">6</td>
          <td class="transparent clickable">7</td>
          <td class="transparent clickable">9</td>
        </tr>
      </table>   
      
    </article>
  </section>
        


 

   

  

  
    
    

    <script>
      
      let divs = [];
      let left = 0;
      let right = 0;
      let mid = 0;
      let searchIndex = 0;
      let step = 0;
      
      
      let searchValue = 0;
      
      
      const container = document.getElementById("arycontainer");
      const description = document.getElementById("description");
      const search = document.getElementById("searchValue");
      
      
      initialize();
      
      
      
      function initialize(){
        description.innerHTML = `バイナリサーチを開始します（<b>次へ</b>を押してください）。`;
        container.innerHTML ="";
        
        let arrayLength = parseInt(document.getElementById("arrayLength2").value);

        divs = createDivs(container, arrayLength, false);
        
        searchValue = parseInt(document.getElementById("searchValueInput2").value);
        search.textContent = searchValue;
        
        left = 0;
        right = divs.length - 1;
        mid = 0;
        step = 0;

      }
      
      function nextStep(){
        //選択ソート 次へ
        if(divs[mid].classList.contains("sorted")){return;}
        
        if(divs.length == countClass(divs, "lowlighted")){
          description.innerHTML = `探索値<b>${searchValue}</b>は存在しません。`;
          return;
        }
        
        if(step%2==0){
          mid = Math.floor((left + right) / 2);
          divs[mid].classList.add("highlighted");
          description.innerHTML = `中央の値は<b>${divs[mid].textContent}</b>です。`;
          
        }else if(step%2==1){
          const midValue = parseInt(divs[mid].textContent);
          if(searchValue == midValue){
            //探索値と中央値が等しいなら、終了
            divs[mid].classList.remove("highlighted");
            divs[mid].classList.add("sorted");
            description.innerHTML = `探索値<b>${searchValue}</b>のインデックス番号は<b>${mid}</b>です（探索終了）。`;
            
          }else if(midValue < searchValue){
            //中央値＜探索値なら、左端を＋１
            description.innerHTML = `探索値<b>${searchValue}</b>は中央より左側にはないので、次に右側を調べます。`;
            for(let j=left;j<=mid;j++){
              divs[j].classList.remove("highlighted");
              divs[j].classList.add("lowlighted");
            }
            
            left = mid + 1;
                   
          }else{
            //中央値＞探索値なら、右端をー１
            description.innerHTML = `探索値<b>${searchValue}</b>は中央より右側にはないので、次に左側を調べます。`;
            
            for(let j=mid;j<=right;j++){
              divs[j].classList.remove("highlighted");
              divs[j].classList.add("lowlighted");
            }
            right = mid - 1;
          }
          
        }
        step++;
      }
      
      function countClass(divs, className){
        let cnt = 0;
        for(let x=0;x<divs.length;x++){
          if(divs[x].classList.contains(className)){
            cnt++;
          }
        }
        return cnt;
      }
      
      function createDivs(container, arrayLength, shuffle = true){
        container.innerHTML = "";
        let aryNum = Array.from({ length: arrayLength }, (_, i) => i);
        
        if(shuffle){aryNum = shuffleArray(aryNum);}
        
        let aryDiv = [];
        
        for(let i=0;i<aryNum.length;i++){
          const div = document.createElement("div");
          div.classList.add("item");
          container.appendChild(div);
          
          const divValue = document.createElement("div");
          divValue.classList.add("divValue");
          divValue.textContent = aryNum[i];
          aryDiv.push(divValue);
          div.appendChild(divValue);
          
          const divIndex = document.createElement("div");
          divIndex.classList.add("divIndex");
          divIndex.textContent = i;
          div.appendChild(divIndex);
        }
        
        return aryDiv;
      }
      
      function shuffleArray(ary) {
        for (let i = (ary.length - 1); 0 < i; i--) {
          let r = Math.floor(Math.random() * (i + 1));
          [ary[i], ary[r]] = [ary[r], ary[i]];
        }
        return ary;
      }
    </script>
</body>
</html>

