<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
	<style id="critical-colors">
	  html { color:#191919; color-scheme: light dark; background: transparent; }
	  @media (prefers-color-scheme: dark) {
	    html { color:#e6e6e6; color-scheme: dark light; background: transparent; }
	  }
	  body { background-color:#f3f3f3; }
	  @media (prefers-color-scheme: dark) {
	    body { background-color:#0b0b0b; }
	  }
	</style>
  <title>海城中学高等学校 情報科</title>
  <script defer src="./js/main.js"></script>
</head>
<body>
  
    
  
  <section>

    
    <article>
      <h2 id="headline_1">(1) クイックソート</h2>
      <h3> クイックソートとは</h3>
      <p><strong> クイックソート</strong>は、最も速くソートできるアルゴリズムなのです。ある基準（ピボットpivot）によって値を２つのグループに分割し、それぞれのグループに対して同じ処理を繰り返します。</p>
      
      <h3>手順</h3>
      <ol>
        <li>開始位置(<tt>start</tt>)が終了位置(<tt>end</tt>)以上の場合、終了します。</li>
        <li>開始位置(<tt>start</tt>)と終了位置(<tt>end</tt>)の中央値を<tt>pivot</tt>に設定します。</li>
        <li>変数<tt>left</tt>に開始位置(<tt>start</tt>)，<tt>right</tt>に終了位置(<tt>end</tt>)を代入します。<tt>left</tt>，<tt>right</tt>は調べる値のインデックス番号です。</li>
        <li> <tt>left</tt>≦<tt>right</tt>のあいだ次の操作を繰り返します。
<ol>
          <li><tt>pivot</tt>より左側で、<tt>pivot</tt>より大きい値を左端から順に探します（左側の交換対象の値）。</li>
            <li><tt>pivot</tt>より右側で、<tt>pivot</tt>より小さい値を右端から順に探します（右側の交換対象の値）。</li>
            <li><tt>left</tt>が<tt>right</tt>以下の場合、左側と右側の交換対象の値を交換し、次の交換対象の値を探します。</li>
          </ol>
        </li>
        <li>
          <b>(4)</b>のループが終了すると、配列は<tt>pivot</tt>を中心に分割されます。
<ol>
          <li>分割された左側の配列に対して、同様に<b>(1)</b>〜<b>(5)</b>を行います。</li>
            <li>分割された右側の配列に対して、同様に<b>(1)</b>〜<b>(5)</b>を行います。</li>
          </ol>
        </li>
      </ol>
      <p>実際のプログラムでは、<tt>pivot</tt>の決め方はいろいろな方法が使われています。上記のように、中央の値にする場合もありますが、そもそもソートされていないので中央の値が昇順における中央値であるとは限りません。そこで、例えば、ランダムに選んだ値を<tt>pivot</tt>にしたり、ランダムに選んだ複数の値の平均値や中央値を<tt>pivot</tt>にすることもあります。</p>
      
      
      <h3>デモンストレーション</h3>
      <div id="quick-sort" class="demo">
        <label for="arrayLength2">配列の長さ:</label>
        <input type="number" id="arrayLength2" value="10" min="2">
        <button onclick="initialize()">配列をリセット</button>

        <div class="container" id="arycontainer"></div>

        <div class="container" id="pivotContainer">
          <div class="item" id="divPivot">
            <div class="divValue" id="pivotValue"></div>
            <div class="divIndex">pivot</div>
          </div>

          <div id="divcountSwap" class="item2"></div>

        </div>

        <div id="description" class="description"></div>

        <button onclick="nextStep()">次へ</button>
      </div>
      
      
      
      <h3>プログラム（位置交換）</h3>
      <p>Colaboratoryのノートブックに書き写しながら、理解しましょう。</p>
      <pre class="python" data-title="クイックソート"><code>
def quick_sort(arr, start, end):
  if start >= end:  # startがend以上の場合、処理を終了
    return
  
  middle = (start + end) // 2   # 中央の位置を求める
  pivot = arr[middle]           # pivotを求める
  left = start                  # 左側の比較対象のインデックス番号
  right = end                   # 右側の比較対象のインデックス番号

  while left <= right:          # leftがright以下のあいだ繰り返す（leftがrightより大きくなったら繰り返しを止める）
    while arr[left] < pivot:    # 左側の値がpivotより小さければ、１つ右の値を対象にする
      left = left + 1
    while arr[right] > pivot:   # 右側の値がpivotより大きければ、１つ左の値を対象にする
      right = right - 1

    if left <= right:           # leftがright以下の場合、要素を交換し、leftとrightを次に進める
      tmp = arr[left]
      arr[left] = arr[right]
      arr[right] = tmp
      
      left = left + 1
      right = right - 1

  # ここまでで、pivotよりも左側に小さい値、右側に大きい値が移動している
  # 再帰的にクイックソートを左側の配列と右側の配列で実行
  quick_sort(arr, start, right) # 左側の配列についてクイックソートを実行
  quick_sort(arr, left, end)    # 右側の配列についてクイックソートを実行

arr = [6, 3, 2, 0, 7, 1, 4, 5]
print(arr)                      # 元の配列の表示

quick_sort(arr, 0, len(arr) - 1)  # クイックソート関数を呼び出し

print(arr)                      # ソート後の配列の表示
      </code></pre>
      <pre class="result"><code>
[6, 3, 2, 0, 7, 1, 4, 5]
[0, 1, 2, 3, 4, 5, 6, 7]
      </code></pre>

      
      <h3>プログラム（Pythonらしい書き方）</h3>
      <p>関数型プログラミング言語であるPythonらしい書き方をすると、次のようになります。上記では<b>既存の配列内の要素の位置を交換して</b>いましたが、次の例では、<b>新しい配列をつくって結果として返す</b>ようにしています。</p>
      <pre class="python" data-title="クイックソート（配列を返す）"><code>
def quick_sort(arr):
  # ソートすべき要素が1つ以下の場合、そのまま返す
  if len(arr) <= 1:
    return arr

  # ピボットとして中央の要素を選択
  pivot = arr[len(arr) // 2]
  left = []
  middle = []
  right = []

  # arrの要素を、ピボットより小さいか、等しいか、大きいかに基づいて、
  # left, middle, rightのリストに分ける
  for x in arr:
    if x < pivot:
      left.append(x)
    elif x == pivot:
      middle.append(x)
    else:
      right.append(x)

  # 配列leftと配列rightを再帰的にソートし、結果を連結して返す
  return quick_sort(left) + middle + quick_sort(right)


arr = [6, 3, 2, 0, 7, 1, 4, 5] # 元のリスト
print(arr)    # ソート前を出力

arr = quick_sort(arr)  # クイックソートを実行

print(arr)    # ソート後
      </code></pre>
      <pre class="result"><code>
[6, 3, 2, 0, 7, 1, 4, 5]
[0, 1, 2, 3, 4, 5, 6, 7]
      </code></pre>
      
      <p>さらに<b>内包表記</b>を用いると、次のように簡潔に書くことができます。</p>
      <pre class="python" data-title="クイックソート（内包表記）"><code>
def quick_sort(arr):
  # ソートすべき要素が1つ以下の場合、そのまま返す
  if len(arr) <= 1:
    return arr

  pivot = arr[len(arr) // 2]
  left = [x for x in arr if x < pivot]       # pivotよりも小さい値を配列leftに格納
  middle = [x for x in arr if x == pivot]    # pivotと等しい値を配列middleに格納
  right = [x for x in arr if x > pivot]      # pivotよりも大きい値を配列rightに格納

  return quick_sort(left) + middle + quick_sort(right) # 配列leftと配列rightを再帰的にソートし、結果を連結して返す


arr = [6, 3, 2, 0, 7, 1, 4, 5]   # 元のリスト
print(arr)    # ソート前

arr = quick_sort(arr) # クイックソートを実行

print(arr)    # ソート後
      </code></pre>
      <pre class="result"><code>
[6, 3, 2, 0, 7, 1, 4, 5]
[0, 1, 2, 3, 4, 5, 6, 7]
      </code></pre>
      
      
      
      <h3>このアルゴリズムの特徴</h3>
      <p>このサイトで紹介した他のソートの交換回数は、\(n^2\) に比例しているのに対して、クイックソートでは基準値を元に２分割しながらソートをしていくので、バイナリサーチ（二分探索）と同じように要素数が大きくなっても処理回数が膨大になりにくいという特徴があります。</p>
      <p>しかしながら、逆順に並べられている場合など、特定の条件においては比較回数を行う回数が膨大になり、選択ソートや挿入ソートよりも処理に必要な時間が多くなることもありますので、必ずしも常にクイックソートの方が優れているというわけではありません（ほぼソートされている配列に対しては、挿入ソートの方が速いです）。</p>
      
      <h4>最小交換回数</h4>
      <p>クイックソートの交換回数が最小となる場合は、要素をちょうど半分ずつに分割していくときです。\(n\) 個の要素を\(x\) 回分割すると、分割後の要素は\(n/2^x\) 個となります。分割後の要素の個数が1になったときにソートが完了しますので、</p>
      \[
          1 = \frac{n}{2^x}
      \]
      <p>と表せます。よって、分割回数\(x\) は、</p>
      \[
          x = \log_2{n}
      \]
      <p>となります。1回の分割に必要な比較回数は\(n\) 回なので、</p>
      \[
          最小比較回数 = n\log_2{n}
      \]
      <p>となります。</p>
      
      <h4>最大交換回数</h4>
      <p>交換回数が最大となる場合は、すべての分割において、要素が1個と残りすべてに分割されるときです。</p>
      <p>1回目で\(n\) 個の要素を1個と\(n-1\) 個，2回目で\(n-1\) 個の要素を1個と\(n-2\) 個，3回目で\(n-2\) 個の要素を1個と\(n-3\) 個，・・・，\(n-1\) 回目で2個の要素を1個ずつに分割してソートが完了します。</p>
      <p>つまり、比較回数は、1回目で\(n-1\) 回，2回目で\(n-2\) 回，3回目で\(n-3\) 回，・・・，\(n-1\)回目で1回となるので、</p>
      \[
          最大比較回数 = (n-1) + (n-2) + \cdots + 1 = \frac{1}{2} n (n-1)
      \]
      <p>となります。</p>
      <p>最大比較回数は他のソートのアルゴリズムと同じくらいですが、このような場合は非常に稀なケースです。ほとんどの場合は、最小比較回数よりも数回多いくらいで完了しますので、他のソートのアルゴリズムよりも高速とされています（平均比較回数を求めるのは非常に困難なので、ここでは省略します）。</p>
    </article>
  </section>
        


 

   

  

  
    
    



    <script>
      let i = 0;
      let j = 0;
      
      let divs = [];
      let target = [];
      let step = 0;
      let left = 0;
      let right = 0;
      let pivot = 0;
      let t = 0;
      let startId = 0;
      let endId = 0;
      let countSwap = 0;
      let divsactive = [];
      
      
      const container = document.getElementById('arycontainer');
      const description = document.getElementById('description');
      const pivotValue = document.getElementById('pivotValue');
      const divcountSwap = document.getElementById('divcountSwap');
      

      initialize();
      

      function initialize(){
        description.innerHTML = `クイックソートを開始します。<b>次へ</b>を押してください。`;
        let arrayLength = parseInt(document.getElementById('arrayLength2').value);

        divs = createDivs(container, arrayLength, true);
        divsactive = [];
        for(let x=0;x<divs.length;x++){
          divsactive.push(true);
          
          divs[x].classList.remove('sorted');
          divs[x].classList.remove('highlighted');
          divs[x].classList.remove('highlighted2');
        }
        
        
        target = [[0, divs.length-1]];
        pivotValue.textContent = "";
        step = 0;
        flgCollision = false;
        left = 0;
        right = 0;
        pivot = 0;
        t = 0;
        countSwap = 0;
        divcountSwap.innerHTML = `交換回数: <b>${countSwap}</b>`;
      }
      
      function nextStep(){
        //クイックソート　次へ
        
        let flgCollision = false;
        
        let arr = [];
        for(let x=0;x<divs.length;x++){
          arr.push(parseInt(divs[x].textContent));
        }
        
        
        console.log(arr);
        console.log("pivot="+pivot+", left=("+left+")"+divs[left].textContent+", right=("+right+")"+divs[right].textContent+", t="+t+", step="+step+", "+target);
        
        if(right<0){
          return;
        }
        if(target.length<=0){
          description.innerHTML = `並び替え完了`;
          for(let x=0;x<divs.length;x++){
            divs[x].classList.add('sorted');
          }
          return;
        }
        

        
        if(step==0){
          //pivotの値と、left,rightの位置を決めます。
          
          startId = target[t][0];
          endId = target[t][1];
          
          pivot = parseInt(divs[Math.floor((startId + endId)/2)].textContent);
          pivotValue.textContent = pivot;
          
          for(let x=0;x<divs.length;x++){
            divs[x].classList.remove('highlighted');
            divs[x].classList.remove('highlighted2');
            
            
            if(x<startId || endId<x){
              divs[x].classList.add('lowlighted');
            }else{
              divs[x].classList.remove('lowlighted');
            }
            
            
            if(!divsactive[x]){
              divs[x].classList.add('sorted');
            }else{
              divs[x].classList.remove('sorted');
            }
            
          }
          
          left = startId;
          right = endId;
          
          description.innerHTML = `左端<b>${left}</b>〜右端<b>${right}</b>の範囲を調べます。pivotを中央の値<b>${pivot}</b>とします。`;
          
          step=1;
        }else if(step==1){
          //左の値がpivotより小さければ、調べる左の位置をひとつ右に移動
          
          for(let x=0;x<divs.length;x++){
            divs[x].classList.remove('swapped');
            divs[x].classList.remove('highlighted2');
          }
          
          if(left > startId){
            divs[left-1].classList.remove('highlighted');
          }
          
          if(parseInt(divs[left].textContent) < pivot){
            divs[left].classList.add('highlighted');
            description.innerHTML = `<b>${left}</b>番目の値<b>${divs[left].textContent}</b> ＜ pivot<b>${pivot}</b>なので、次に進みます。`;
            left++;
          
            
          }else{
            divs[left].classList.add('highlighted2');
            description.innerHTML = `<b>${left}</b>番目の値<b>${divs[left].textContent}</b> ≧ pivot<b>${pivot}</b>なので、交換対象とします。次に、交換する相手を右端から調べます。`;

            step=2;
                              
          }
          
        }else if(step==2){
          if(right < endId){
            divs[right+1].classList.remove('highlighted');
          }
          
          if(parseInt(divs[right].textContent) > pivot){
            divs[right].classList.add('highlighted');
            description.innerHTML = `<b>${right}</b>番目の値<b>${divs[right].textContent}</b> ＞ pivot<b>${pivot}</b>なので、次に進みます。`;
            right--;
          
          }else{
            divs[right].classList.add('highlighted2');
            description.innerHTML = `<b>${right}</b>番目の値<b>${divs[right].textContent}</b> ≦ pivot<b>${pivot}</b>なので、左側の交換対象と交換します。`;
            step=3;
          }
          
        }else if(step==3){
          if(right <= left){
            flgCollision = true;

          }else{
            swap(left, right);
            description.innerHTML = `<b>${left}</b>番目の値<b>${divs[left].textContent}</b>と<b>${right}</b>番目の値<b>${divs[right].textContent}</b>を交換しました。次に、再び左側の続きを調べていきます。`;
            left++;
            right--;
            step=1;
          }
        }
        
        
        if(flgCollision){
          description.innerHTML = `左端からの探索と右端からの探索がぶつかり、pivotより小さいグループと大きいグループができました。これらのグループについて、それぞれもう一度同様の操作をします。`;
          target.shift();
          if(right+1 < endId){
            target.unshift([right+1, endId]);
          }
          if(startId < left-1){
            target.unshift([startId, left-1]);
          }
          
          for(let x=0;x<divs.length;x++){
            divsactive[x] = false;
          }
          
          for(let x=0;x<target.length;x++){
            for(let y=target[x][0];y<=target[x][1];y++){
              divsactive[y] = true;
            }
          }
          flgCollision=false;
          step=0;
        }
        
      }

      function swap(i, j){
        [divs[i].textContent, divs[j].textContent] = [divs[j].textContent, divs[i].textContent];
        
        countSwap++;
        divcountSwap.innerHTML = `交換回数: <b>${countSwap}</b>`;
        divs[i].classList.remove('highlighted');
        divs[j].classList.remove('highlighted');
        divs[i].classList.add('swapped');
        divs[j].classList.add('swapped');
      }

      function createDivs(container, arrayLength, shuffle = true){
        container.innerHTML = '';
        let aryNum = Array.from({ length: arrayLength }, (_, i) => i);
        
        if(shuffle){aryNum = shuffleArray(aryNum);}
        
        let aryDiv = [];
        
        for(let i=0;i<aryNum.length;i++){
          const div = document.createElement('div');
          div.classList.add('item');
          container.appendChild(div);
          
          const divValue = document.createElement('div');
          divValue.classList.add('divValue');
          divValue.textContent = aryNum[i];
          aryDiv.push(divValue);
          div.appendChild(divValue);
          
          const divIndex = document.createElement('div');
          divIndex.classList.add('divIndex');
          divIndex.textContent = i;
          div.appendChild(divIndex);
        }
        
        return aryDiv;
      }
      
      function shuffleArray(ary) {
        for (let i = (ary.length - 1); 0 < i; i--) {
          let r = Math.floor(Math.random() * (i + 1));
          [ary[i], ary[r]] = [ary[r], ary[i]];
        }
        return ary;
      }
    </script>
  
</body>
</html>

