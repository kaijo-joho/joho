<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
	<style id="critical-colors">
	  html { color:#191919; color-scheme: light dark; background: transparent; }
	  @media (prefers-color-scheme: dark) {
	    html { color:#e6e6e6; color-scheme: dark light; background: transparent; }
	  }
	  body { background-color:#f3f3f3; }
	  @media (prefers-color-scheme: dark) {
	    body { background-color:#0b0b0b; }
	  }
	</style>
  <title>海城中学高等学校 情報科</title>
  <script defer src="./js/main.js"></script>
</head>
<body>
  
    
  
  <section>

    
    
    <article>
      <h2 id="headline_1">(1) ２値交換</h2>
      <p>２つの変数の値を入れ替えることを<strong>２値交換</strong>といいます。変数の値を入れ替えるとき、値を一時的に別の変数に入れておきます。一時的に値を入れておくので、一時的（temporary）を略して<tt>tmp</tt>や<tt>temp</tt>といった変数名にすることが多いです。</p>
      

      
      <h3>変数<tt>a</tt>と変数<tt>b</tt>の交換</h3>
      <p>変数<tt>a</tt>と変数<tt>b</tt>の値を交換するときには、次の手順になります。</p>
      <ol>
        <li>変数<tt>tmp</tt>に変数<tt>a</tt>を代入する。</li>
        <li>変数<tt>a</tt>に変数<tt>b</tt>を代入する。</li>
        <li>変数<tt>b</tt>に変数<tt>tmp</tt>を代入する。</li>
      </ol>
      <p class="center">
        <img src="./img/py43_001.png" alt="２値交換">
      </p>
      <p>これをプログラムで書くと、次のようになります。</p>
      <p>Colaboratoryのノートブックに書き写しながら、理解しましょう。</p>
      <pre class="python" data-title="２値交換"><code>
# 交換前の値
a = 5
b = 7
print("交換前: a =",a,", b =",b, sep="")  # 交換前の値を表示

# 変数aとbの中身を交換
tmp = a
a = b
b = tmp

print("交換後: a =",a,", b =",b, sep="")  # 交換後の値を表示
      </code></pre>
      <pre class="result"><code>
交換前: a = 5, b = 7
交換後: a = 7, b = 5
      </code></pre>
      
      <p>Pythonでは、変数<tt>a</tt>と<tt>b</tt>を入れ換えるとき、次の１行で書くことができます。</p>
      <pre class="python example" data-title=""><code>b, a = a, b</code></pre>

      
      <p>ただし、<span class="bgcolor_lighterred"><b>共通テスト用プログラム表記（DNCL）</b>では前者の書き方をしているため、このサイトではそれにしたがって変数<tt class="background-transparent">tmp</tt>を用いた前者の書き方をします。</span></p>
      
      <h3 id="swap-element">配列内の要素の交換</h3>
      <p>配列内の要素を交換する場合は、変数<tt>tmp</tt>を用いて次のように書きます。</p>
      <p>Colaboratoryのノートブックに書き写しながら、理解しましょう。</p>
      <pre class="python" data-title="配列内の要素の交換"><code>
# 交換前の値
arr = [0, 1, 2, 3, 4, 5, 6, 7]
print(arr)  # 交換前の値を表示

# 3番目と5番目を入れ換える(番号は0で始まるものとする)。
tmp = arr[3]
arr[3] = arr[5]
arr[5] = tmp

print(arr)  # 交換後の値を表示
      </code></pre>
      <pre class="result"><code>
[0, 1, 2, 3, 4, 5, 6, 7]
[0, 1, 2, 5, 4, 3, 6, 7]
      </code></pre>

    </article>
    <article>
      <h2 id="headline_2">(2) バブルソート（単純交換法）</h2>

      
      <h3>バブルソート（単純交換法）とは</h3>
      <p><strong>バブルソート（単純交換法）</strong>は、すべての隣り合った値を比較して、小さい方が前になるように交換していく方法です。液中の泡が浮かび上がるように値を移動させるので、バブルソートといいます。ただし、総当たりで繰り返し比較交換していくので、データが大量にあると処理に時間がかかってしまいます。</p>
      
      <h3>手順</h3>
      <ol>
        <li>整列していない配列（リスト）を用意します。</li>
        <li>末尾の２つの値を比較し、右側の値が小さい場合は、２つの値を交換します。</li>
        <li>１つ前の２つの値を比較し、右側の値が小さい場合は、２つの値を交換します。</li>
        <li><b>(3)</b>を先頭まで繰り返します。すると、最も小さい値が先頭にやってきます（先頭のみが<b>整列済み</b>になりました）。</li>
        <li><b>(2)</b>〜<b>(3)</b>を未整列の先頭まで繰り返し、すべての値が整列済みになれば終了します。</li>
      </ol>
      
      <h3>デモンストレーション</h3>
      <div id="bubble-sort" class="demo">
        <label for="arrayLength1">配列の長さ:</label>
        <input type="number" id="arrayLength1" class="arrayLength" value="8" min="2">
        <button onclick="initialize()">配列をリセット</button>
        <!--
        <details>
          <summary>詳細設定</summary>
          <input type="radio" name="arrayType1" value="serial" checked> 連番：<br>
          <input type="radio" name="arrayType1" value="random"> 乱数：<input type="number">〜<input type="number"><br>
          <input type="radio" name="arrayType1" value="user"> 指定：<input type="text">
        </details>
        -->
        <div class="container" id="arycontainer"></div>
        <div id="description" class="description"></div>
        <button onclick="nextStep()">次へ</button>
      </div>

      
      <h3>プログラム</h3>
      <h4>バブルソートの基本</h4>
      <p>Colaboratoryのノートブックに書き写しながら、理解しましょう。</p>
      <p><tt>for j in range(n - 2, i - 1, -1):</tt>では、<tt>j</tt>が<tt>n - 2</tt>から<tt>i</tt>まで<tt>1</tt>ずつ減らしながら繰り返します。</p>
      <p>range関数の使い方（<tt>range(開始値, 終了値, ステップ)</tt>）で、ステップに負数を指定する場合は、<a href="./py24.html#range_a_b_c_reduce" target="_blank">減っていくforループ</a>を参照してください。</p>
      <pre class="python" data-title="バブルソート"><code>
arr = [6, 3, 2, 0, 7, 1, 4, 5]            # 元のリスト
print("ソート前", arr)                    # ソート前を出力
n = len(arr)

for i in range(n - 1):                    # 調べる範囲の開始位置を１つずつ後へ移動していく
  for j in range(n - 2, i - 1, -1):     # 末尾から先頭に向かって、隣り合う２値を比較する
    if arr[j] > arr[j + 1]:           # 隣り合う２値の末尾側が小さかったら交換する
      tmp = arr[j]
      arr[j] = arr[j + 1]
      arr[j + 1] = tmp
        
print("ソート後", arr)                    # ソート後を出力
      </code></pre>
      <pre class="result"><code>
ソート前 [6, 3, 2, 0, 7, 1, 4, 5]
ソート後 [0, 1, 2, 3, 4, 5, 6, 7]
      </code></pre>

      
      <h4>手順</h4>
      <p>バブルソートの2つのループ変数<tt>i</tt>，<tt>j</tt>の変化の様子を確かめるために、次のようなプログラムを実行してみましょう。</p>
      <pre class="python" data-title="バブルソート（iとjの変化）"><code>
        n = 8
        print("i", "j")
        for i in range(n - 1):                    # 調べる範囲の開始位置を１つずつ後へ移動していく
          for j in range(n - 2, i - 1, -1):     # 末尾から先頭に向かって、隣り合う２値を比較する
            print(i, j)</code></pre>
      <pre class="result"><code>
        i j
        0 6
        0 5
        0 4
        (略)
        5 6
        5 5
        6 6
      </code></pre>
      <p>これを実行すると、<tt>n = 8</tt>のとき、<tt>i</tt>と<tt>j</tt>の値は次のように変化していることがわかります。</p>
      <p>
        <tt>i = 0</tt>のとき、<tt>j = 6 ⇒ 5 ⇒ 4 ⇒ 3 ⇒ 2 ⇒ 1 ⇒ 0</tt><br>
        <tt>i = 1</tt>のとき、<tt>j = 6 ⇒ 5 ⇒ 4 ⇒ 3 ⇒ 2 ⇒ 1</tt><br>
        ...<br>
        <tt>i = 5</tt>のとき、<tt>j = 6 ⇒ 5</tt><br>
        <tt>i = 6</tt>のとき、<tt>j = 6</tt><br>
      </p>
      <p>つまり、<tt>i</tt>回目の繰り返しで、配列の末尾から先頭に向かって隣同士の要素を比較・交換していくことで、<tt>i</tt>番目の要素が整列済みになることがわかります。</p>
      <p>このとき<tt>j</tt>の値は末尾の１つ前の値（<tt>n-2</tt>）から、<tt>i</tt>まで1ずつ減らしながら繰り返しています。<tt>j</tt>の値が<tt>i</tt>までなのは、<tt>i</tt>番目までは既に整列済みになっているので、比較する必要がないからです。</p>
      
      
      <h4>バブルソートの途中経過</h4>
      <p>さきほどのプログラムを次のように書き換えて、途中経過を出力してみましょう。</p>
      <pre class="python" data-title="バブルソート（途中経過を出力）"><code>
arr = [6, 3, 2, 0, 7, 1, 4, 5]            # 元のリスト
print(arr)                                # ソート前を出力
n = len(arr)
        
print("------------------------")

for i in range(n - 1):                    # 調べる範囲の開始位置を１つずつ後へ移動していく
  for j in range(n - 2, i - 1, -1):     # 末尾から先頭に向かって、隣り合う２値を比較する
    if arr[j] > arr[j + 1]:           # 隣り合う２値の末尾側が小さかったら交換する
      tmp = arr[j]
      arr[j] = arr[j + 1]
      arr[j + 1] = tmp
      print(arr)                    # 途中経過を出力
        
print("------------------------")      
print(arr)                                # ソート後を出力
      </code></pre>
      <pre class="result"><code>
[6, 3, 2, 0, 7, 1, 4, 5]
------------------------
[6, 3, 2, 0, 1, 7, 4, 5]
[6, 3, 0, 2, 1, 7, 4, 5]
[6, 0, 3, 2, 1, 7, 4, 5]
[0, 6, 3, 2, 1, 7, 4, 5]
[0, 6, 3, 2, 1, 4, 7, 5]
[0, 6, 3, 1, 2, 4, 7, 5]
[0, 6, 1, 3, 2, 4, 7, 5]
[0, 1, 6, 3, 2, 4, 7, 5]
[0, 1, 6, 3, 2, 4, 5, 7]
[0, 1, 6, 2, 3, 4, 5, 7]
[0, 1, 2, 6, 3, 4, 5, 7]
[0, 1, 2, 3, 6, 4, 5, 7]
[0, 1, 2, 3, 4, 6, 5, 7]
[0, 1, 2, 3, 4, 5, 6, 7]
------------------------
[0, 1, 2, 3, 4, 5, 6, 7]
      </code></pre>
      
      <h3>このアルゴリズムの特徴</h3>
      <h4>最小交換回数</h4>
      <p>最小交換回数はすべてがはじめから整列済みである場合なので、\(0\)回です。</p>
      
      <h4>最大交換回数（比較回数）</h4>
      <p>最大交換回数は、すべての比較において交換が生じた場合です。つまり、最大交換回数＝比較回数です。</p>
      <p>整列済みではない部分の要素数が \(n\) 個の場合、1つの要素を整列済みにするまでの比較回数は \(n-1\) 回です。これが次の要素を確定するときには、整列済みではない部分の要素数が \(n-1\)個なので、比較回数は　\(n-2\) となります。このように、 \(n\) 個の要素をすべて整列済みにするための比較回数（＝最大交換回数）を求めると、
      \[
        最大交換回数 = (n-1) + (n-2) + (n-3) + \cdots + 2 + 1 = \frac{1}{2}n(n-1)
      \]
      となります。</p>
      
      

      <h3>練習問題</h3>
      <h4>問1</h4>
      <p id="question-sentence-q1"></p>
      <table id="sort-table-q1" class="table-toggle-cell"></table>
      
      <h4>問2</h4>
      <p id="question-sentence-q2"></p>
      <table id="sort-table-q2" class="table-toggle-cell"></table>
      
      <h4>問3</h4>
      <p id="question-sentence-q3"></p>
      <table id="sort-table-q3" class="table-toggle-cell"></table>

      <h4>問4</h4>
      <p id="question-sentence-q4"></p>
      <table id="sort-table-q4" class="table-toggle-cell"></table>
    </article>
    
  </section>
        


 

   

  

  
  
  


  <script>    

    let divs = [];
    let i = 0;
    let j = 0;
    let countCompare = 0;
    let countSwap = 0;

    const container = document.getElementById("arycontainer");
    const description = document.getElementById("description");


    initialize();
    question_initialize();


    function initialize(){
      description.textContent = `バブルソートを開始します。`;
      container.innerHTML ="";

      let arrayLength = parseInt(document.getElementById("arrayLength1").value);

      divs = createDivs(container, arrayLength, true);

      i = 0;
      j = divs.length - 2;
      countCompare = 0;
      countSwap = 0;
    }

    function nextStep(){
      //バブルソート　次へ
      if(i>=divs.length-1){
        divs[j+1].classList.add("sorted");
        description.innerHTML = `最後に ${divs[j+1].textContent} が整列済みになり、終了です。<br>比較回数${countCompare}，交換回数${countSwap}`;
        return;
      }

      if(j+2<divs.length){
        divs[j+2].classList.remove("highlighted");
        divs[j+2].classList.remove("swapped");
      }
      divs[j+1].classList.remove("swapped");


      if(j<i){
        divs[j+1].classList.remove("highlighted");
        divs[j+2].classList.remove("highlighted");
        divs[j+1].classList.remove("swapped");
        divs[j+2].classList.remove("swapped");
        divs[j+1].classList.add("sorted");
        description.innerHTML = ` ${divs[j+1].textContent} が整列済みになりました。<br>比較回数${countCompare}，交換回数${countSwap}`;
        i++;
        j = divs.length - 2;
      }else{
        if(divs[j].classList.contains("highlighted") && divs[j+1].classList.contains("highlighted")){
          if(parseInt(divs[j].textContent) > parseInt(divs[j+1].textContent)){
            divs[j].classList.remove("highlighted");
            divs[j+1].classList.remove("highlighted");
            [divs[j].textContent, divs[j+1].textContent] = [divs[j+1].textContent, divs[j].textContent];
            countSwap++;
            divs[j].classList.add("swapped");
            divs[j+1].classList.add("swapped");
            description.innerHTML = ` ${divs[j+1].textContent} ＞ ${divs[j].textContent} なので、交換しました。<br><tt>i=${i}, j=${j}</tt>，比較回数${countCompare}，交換回数${countSwap}`;

          }else{
            description.innerHTML = ` ${divs[j].textContent} ≦ ${divs[j+1].textContent} なので、交換しません。<br><tt>i=${i}, j=${j}</tt>，比較回数${countCompare}，交換回数${countSwap}`;
          }

          j--;

        }else{
          countCompare++;
          divs[j].classList.add("highlighted");
          divs[j+1].classList.add("highlighted");
          description.innerHTML = ` ${divs[j].textContent} と ${divs[j+1].textContent} を比較します。<br><tt>i=${i}, j=${j}</tt>，比較回数${countCompare}`;
        } 
      }
    }

    
    
    function createDivs(container, arrayLength, shuffle = true){
      container.innerHTML = "";
      let aryNum = Array.from({ length: arrayLength }, (_, i) => i);

      if(shuffle){aryNum = shuffleArray(aryNum);}

      let aryDiv = [];

      for(let i=0;i<aryNum.length;i++){
        const div = document.createElement("div");
        div.classList.add("item");
        container.appendChild(div);

        const divValue = document.createElement("div");
        divValue.classList.add("divValue");
        divValue.textContent = aryNum[i];
        aryDiv.push(divValue);
        div.appendChild(divValue);

        const divIndex = document.createElement("div");
        divIndex.classList.add("divIndex");
        divIndex.textContent = i;
        div.appendChild(divIndex);
      }

      return aryDiv;
    }

    
    // バブルソートの関数
    function bubbleSort(arr) {
        const process = [arr.slice()];  // ソートの途中経過を保存
        let compareCount = 0;
        let swapCount = 0;

        for (let i = 0; i < arr.length - 1; i++) {
            for (let j = arr.length - 2; j >= i; j--) {
                compareCount++;
                if (arr[j] > arr[j + 1]) {
                    // 交換
                    [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                    swapCount++;
                    if (process[process.length - 1].toString() !== arr.toString()) {
                        process.push(arr.slice());  // 途中経過を保存
                    }
                }
            }
        }
        return { process, compareCount, swapCount };
    }

    // テーブルを更新する関数
    function updateTable(process, questionNumber, sortName) {
        const arr = process[0];

        // 問題文の更新
        const questionSentence = document.getElementById("question-sentence-" + questionNumber);
        questionSentence.innerHTML = `次の表は、配列<tt>arr = [${arr}]</tt>を${sortName}によって昇順に並び替える過程を表している。表中の空欄に適する数字を答えなさい。`;

        // テーブルのクリア
        const sortTable = document.getElementById("sort-table-" + questionNumber);
        sortTable.innerHTML = "";

        // テーブルヘッドの作成
        const thead = document.createElement("thead");
        const tableHeader = document.createElement("tr");
        const thInitial = document.createElement("th");
        thInitial.innerHTML = "＼";
        tableHeader.appendChild(thInitial);

        // 配列のインデックスをヘッダーに追加
        arr.forEach((_, i) => {
            const th = document.createElement("th");
            th.innerHTML = `<tt>${i}</tt>`;
            tableHeader.appendChild(th);
        });

        thead.appendChild(tableHeader);
        sortTable.appendChild(thead);

        // テーブルボディの作成
        const tbody = document.createElement("tbody");

        process.forEach((step, i) => {
            const row = document.createElement("tr");
            const stepTitle = document.createElement("th");

            if (i === 0) {
                stepTitle.innerText = "初期値";
            } else {
                stepTitle.innerText = `${i}回目`;
            }

            row.appendChild(stepTitle);

            // 配列の値を行に追加
            step.forEach(value => {
                const td = document.createElement("td");
                if (i === 0 || i === process.length - 1) {
                    td.innerText = value;
                } else {
                    td.className = "transparent clickable";
                    td.innerText = value;
                }
                row.appendChild(td);
            });

            tbody.appendChild(row);
        });

        sortTable.appendChild(tbody);
    }

    // 初期化
    function question_initialize(){
        updateTable(createQuestionArray([8,2,4,1]), "q1", "バブルソート");
        updateTable(createQuestionRandomArray(5, 5), "q2", "バブルソート");
        updateTable(createQuestionRandomArray(6, 6), "q3", "バブルソート");
        updateTable(createQuestionRandomArray(10, 10), "q4", "バブルソート");
    }

    // 配列からソート過程を作成する関数
    function createQuestionArray(arr) {
        const result = bubbleSort(arr.slice());   // ソート方法
        return result.process;
    }

    // ランダム配列を生成する関数
    function createQuestionRandomArray(arrLength, minSwapTimes) {
        const arr = Array.from({length: arrLength}, (_, i) => i);

        let process = []; // 初期化（空の配列として宣言）
        let compareCount = 0;
        let swapCount = 0;

        for(let i = 0; i < 500; i++){
            shuffleArray(arr);

            const result = bubbleSort(arr.slice());   // ソート方法
            process = result.process;

            if(process.length >= minSwapTimes){
                return process;
            }
        }
    }

    // 配列をシャッフルする関数
    function shuffleArray(ary) {
      for (let i = (ary.length - 1); 0 < i; i--) {
        let r = Math.floor(Math.random() * (i + 1));
        [ary[i], ary[r]] = [ary[r], ary[i]];
      }
      return ary;
    }
  </script>
  
</body>
</html>

