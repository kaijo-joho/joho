<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
	<style id="critical-colors">
	  html { color:#191919; color-scheme: light dark; background: transparent; }
	  @media (prefers-color-scheme: dark) {
	    html { color:#e6e6e6; color-scheme: dark light; background: transparent; }
	  }
	  body { background-color:#f3f3f3; }
	  @media (prefers-color-scheme: dark) {
	    body { background-color:#0b0b0b; }
	  }
	</style>
  <title>海城中学高等学校 情報科</title>
  <script defer src="./js/main.js"></script>
</head>
<body>
  
    
  
  <section>

    
    
    <article>
      <h2 id="headline_1">(1) 挿入ソート</h2>
      <h3>挿入ソートとは</h3>
      <p><strong>挿入ソート</strong>は、データを抜き出して、順番に並ぶ位置に挿入していく方法です。</p>
      
      <h3>手順</h3>
      <ol>
        <li>配列の先頭を整列済みとします。</li>
        <li>未整列部分の先頭を変数<tt>tmp</tt>に入れます。</li>
        <li><tt>tmp</tt>の値を整列済みのどこに挿入するかを、整列済みの値を後から調べていきます。</li>
        <li>整列済みのうち<tt>tmp</tt>より大きい要素を順に、右に１つずつずらします。</li>
        <li><b>(4)</b>の処理が終わったら、そこに<tt>tmp</tt>を挿入します。</li>
        <li>すべての要素が整列済みになるまで、<b>(2)</b>〜<b>(5)</b>を繰り返します。</li>
      </ol>
      
      <h3>デモンストレーション</h3>
      <div id="insertion-sort" class="demo">
        <label for="arrayLength1">配列の長さ:</label>
        <input type="number" id="arrayLength1" value="8" min="2">
        <button onclick="initialize()">配列をリセット</button>

        <div class="container" id="arycontainer"></div>

        <div class="container" id="tmpcontainer">
          <div class="item" id="divTmp">
            <div class="divValue" id="divTmpValue1"></div>
            <div class="divIndex">tmp</div>
          </div>
        </div>
        <div id="description" class="description"></div>
        <button onclick="nextstep()">次へ</button>
      </div>

      
      <h3>プログラム</h3>
      <p>Colaboratoryのノートブックに書き写しながら、理解しましょう。</p>
      
      <h4>for文を使った挿入ソートのプログラム</h4>
      <p>整列済みのうち<tt>tmp</tt>よりも大きい要素を順に、右に１つずつ移動する操作をfor文で表すと次のようになります。</p>
      <pre class="python" data-title="挿入ソート"><code>
arr = [6, 3, 2, 0, 7, 1, 4, 5] # 元のリスト
print(arr)    # ソート前を出力
n = len(arr)
print("------------------------")

for i in range(1, n):              # 未整列部分から、順番に１つずつ値を取り出していく
  tmp = arr[i]                   # 挿入する値を変数tmpに入れる
  ins = 0                        # 挿入する位置の変数(初期値は暫定的に0)

  for j in range(i - 1, -1, -1): # 整列済みのどこに挿入すればいいかを、後から前に向かって順番に比較していく
    if arr[j] > tmp:           # もし挿入する値が小さければ、
      arr[j + 1] = arr[j]    # 調べた値を１つずつ後にずらす
    else:                      # そうでなければ、
      ins = j + 1            # 挿入する位置をj+1に確定する
      break                  # ずらす処理を止める
  
  arr[ins] = tmp                 # ずらす処理が終わった位置に挿入する値を入れる
  print(arr)                     # 途中経過を出力

print("------------------------")
print(arr)     # ソート後
      </code></pre>
      <pre class="result"><code>
[6, 3, 2, 0, 7, 1, 4, 5]
------------------------
[3, 6, 2, 0, 7, 1, 4, 5]
[2, 3, 6, 0, 7, 1, 4, 5]
[0, 2, 3, 6, 7, 1, 4, 5]
[0, 2, 3, 6, 7, 1, 4, 5]
[0, 1, 2, 3, 6, 7, 4, 5]
[0, 1, 2, 3, 4, 6, 7, 5]
[0, 1, 2, 3, 4, 5, 6, 7]
------------------------
[0, 1, 2, 3, 4, 5, 6, 7]
      </code></pre>
      
      <p><tt>for j in range(i - 1, -1, -1)</tt>について、ステップが負数になるときの指定のしかたは、<a href="./py24.html#range_a_b_c_reduce" target="_blank">2-4. 繰り返し処理（for文）① 減っていくforループ</a>を参照してください。</p>
      
      
      

      <h4>while文を使った挿入ソートのプログラム</h4>
      <p>整列済みのうち<tt>tmp</tt>よりも大きい要素を順に、右に１つずつ移動する操作をwhile文で表すと次のようになります。</p>
      <pre class="python" data-title="挿入ソート"><code>
arr = [6, 3, 2, 0, 7, 1, 4, 5] # 元のリスト
print(arr)    # ソート前を出力
n = len(arr)
print("------------------------")

for i in range(1, n):                  # 未整列部分から、順番に１つずつ値を取り出していく
  tmp = arr[i]                   # 挿入する値を変数tmpに入れる
  j = i - 1                      # jはiのひとつ前から先頭に向かって1ずつ減らしながら繰り返す
  while j >= 0 and arr[j] > tmp: # jの値が正かつj番目の要素がtmpよりも大きいあいだ繰り返す
    arr[j + 1] = arr[j]    # j番目の要素をひとつ右に移動する
    j = j - 1              # jの値を1減らす（ひとつ前の要素を次の対象とする）
  arr[j + 1] = tmp               # whileループが終わったら（tmpよりも大きい要素は１つずつ右に移動している）、j+1番目にtmpを代入する
  print(arr)

print("------------------------")
print(arr)     # ソート後
      </code></pre>
      <pre class="result"><code>
[6, 3, 2, 0, 7, 1, 4, 5]
------------------------
[3, 6, 2, 0, 7, 1, 4, 5]
[2, 3, 6, 0, 7, 1, 4, 5]
[0, 2, 3, 6, 7, 1, 4, 5]
[0, 2, 3, 6, 7, 1, 4, 5]
[0, 1, 2, 3, 6, 7, 4, 5]
[0, 1, 2, 3, 4, 6, 7, 5]
[0, 1, 2, 3, 4, 5, 6, 7]
------------------------
[0, 1, 2, 3, 4, 5, 6, 7]
      </code></pre>
      
      <h3>このアルゴリズムの特徴</h3>

      
      <h4>最大比較回数・最大交換回数</h4>
      <p>最大交換回数は、すべての比較において交換する場合なので、最大交換回数＝最大比較回数となります。</p>
      <p>0番目の要素は比較・交換をしなくても整列済みとします。</p>
      <p>1番目以降の要素は、比較回数が最も多くなるのは、要素を左端まで交換していくときです。つまり、1番目の要素は最大1回，2番目の要素は最大2回，・・・，\(n-1\) 番目の要素は最大 \(n-1\) 回となるので、</p>
      
      \[
        最大比較回数・最大交換回数 = 1 + 2 + \cdots + (n-1) = \frac{1}{2}n(n-1)
      \]
      
      <p>となります。</p>
      
      <h4>最小比較回数・最小交換回数</h4>
      <p>最も比較回数が少ない場合は、すでに整列済みの配列の場合です。</p>
      <p>0番目の要素は比較・交換しなくても整列済みとします。</p>
      <p>1番目以降の要素は、比較回数が最も少なくなるのは、整列済みの右端と比較するときなので、1番目の要素は最小1回，2番目の要素は最小1回，・・・，\(n\) 番目の要素は最小１回となるので、</p>
      \[
        最小比較回数 = n-1
      \]
      <p>となります。</p>
      <p>また、このとき交換は起こらないので、最小交換回数は0(ゼロ)となります。</p>

      <h4>平均比較回数・平均交換回数</h4>
      <p>1番目以降の要素について、平均比較回数と平均交換回数は、挿入位置が整列済みの中央になるときと考えられます。</p>
      <p>つまり、\(i\) 番目の要素を挿入する場合、整列済みの要素は \(i\) 個あるので、平均比較回数と平均交換回数は、\(i/2\) 回となります。つまり、1番目の要素は\(1/2\) 回，2番目の要素は\(2/2\) 回，・・・，\(n\) 番目の要素は\((n-1)/2\) 回となるので、</p>

      \[
        平均比較回数・平均交換回数 = \frac{1}{2} + \frac{2}{2} + \cdots + \frac{n-1}{2} = \frac{1}{4}n(n-1)
      \]
      <p>となります。</p>
      
      <h4>このアルゴリズムの特徴</h4>
      <p>バブルソートは、隣り合う２つの値を比較していきますが、挿入ソートでは離れた位置の値を比較して適切な位置に挿入を行っていくので、整列されている部分が多いほど交換回数が少なくなり、他の複雑なアルゴリズムよりも高速に並び替えができます。例えば、要素が頻繁に追加され、その都度並び替えを行うような環境では、追加された要素をすぐに正しい位置に挿入できます。</p>
      <p>平均交換回数は \(n^2\) に比例して大きくなりますが、ある程度に分割することによって効率よくソートすることができます。このように分割した配列に挿入ソートをする方法は、シェルソートやマージソートという別のアルゴリズムに応用されています。</p>

      
      
      
    
    
      <h3>練習問題</h3>

      <h4>問1</h4>
      <p id="question-sentence-q1"></p>
      <table id="sort-table-q1" class="table-toggle-cell"></table>
      
      <h4>問2</h4>
      <p id="question-sentence-q2"></p>
      <table id="sort-table-q2" class="table-toggle-cell"></table>
      
      <h4>問3</h4>
      <p id="question-sentence-q3"></p>
      <table id="sort-table-q3" class="table-toggle-cell"></table>

      <h4>問4</h4>
      <p id="question-sentence-q4"></p>
      <table id="sort-table-q4" class="table-toggle-cell"></table>
      
    </article>
    
    
  </section>
        


 

   

  

  
    
    



    <script>
      
      let divs = [];
      let step = 0;
      let i = 0;
      let j = 0;
      let countCompare = 0;
      let countSwap = 0;
      
      
      const container = document.getElementById('arycontainer');
      const description = document.getElementById('description');
      const divTmp = document.getElementById('divTmpValue1');
      
      initialize();
      question_initialize();
      
      
      function initialize(){
        description.innerHTML = `<p>挿入ソートを開始します。<b>次へ</b>を押してください。</p>`;
        container.innerHTML ='';
        
        let arrayLength = parseInt(document.getElementById('arrayLength1').value);
        
        divs = createDivs(container, arrayLength, true);
        step = 0;
        divTmp.textContent = ""
        i = 1;
        j = 0;
        countCompare = 0;
        countSwap = 0;
      }
      
      function nextstep(){
        //挿入ソート　次へ
        
        if(i>=divs.length){
          description.innerHTML = `<p>すべてが整列済みになり、並び替え完了です。</p>`;
          return;
        }
        
        if(step==0 && !divs[0].classList.contains('sorted')){
          divs[0].classList.add('sorted');
          description.innerHTML = `<p>先頭の要素<b>${divs[0].textContent}</b>を整列済みとします。</p>`;
          
        }else if(step%4==0){
          divTmp.textContent = divs[i].textContent;
          divs[i].classList.add('highlighted');
          divTmp.classList.add('highlighted');
          description.innerHTML = `<p><tt>i = ${i}</tt></p><p>未整列の先頭（<b>${i}</b>番目）の要素<b>${divs[i].textContent}</b>を変数<tt>tmp</tt>に入れます。</p>`;
          step++;
        }else if(step%4==1){
          divs[i].textContent = "";
          description.innerHTML = `<p><tt>i = ${i}</tt></p><p><tt>tmp</tt>に入れた<b>${i}</b>番目の要素をカラにします。</p>`;
          j = i-1;
          step++;
        }else if(step%4==2){
          divs[i].classList.remove('highlighted');
          divTmp.classList.remove('highlighted');
          if(j>=0 && parseInt(divs[j].textContent) > parseInt(divTmp.textContent)){
            divs[j+1].textContent = divs[j].textContent;
            divs[j].textContent = "";
            divs[j+1].classList.add('sorted');
            divs[j].classList.add('sorted');
            description.innerHTML = `<p><tt>i = ${i}</tt>, <tt>j = ${j}</tt>のとき、<tt>arr[j + 1] = arr[j]</tt></p><p>tmp<b>${divTmp.textContent}</b>より大きい整列済みの要素を、後から順に右に１つずつずらします。</p>`;
            j--;
          }else{
            divs[j+1].classList.remove('highlighted');
            divs[j+1].classList.add('sorted');
            divs[j+1].textContent = divTmp.textContent;
            description.innerHTML = `<p><tt>i = ${i}</tt>, <tt>j = ${j}</tt>のとき、<tt>arr[ins] = tmp</tt>(<tt>arr[j + 1] = tmp</tt>)</p><p><tt>tmp</tt>(<b>${divTmp.textContent}</b>)を<b>${j + 1}</b>番目に入れます。</p>`;
            
            divTmp.textContent = "";
            step++;
          }
          
        }else if(step%4==3){
          i++;
          step++;
          
        }else{
          step++;
        }
        
        
      }
      
      
      function createDivs(container, arrayLength, shuffle = true){
        container.innerHTML = '';
        let aryNum = Array.from({ length: arrayLength }, (_, i) => i);
        
        if(shuffle){aryNum = shuffleArray(aryNum);}
        
        let aryDiv = [];
        
        for(let i=0;i<aryNum.length;i++){
          const div = document.createElement('div');
          div.classList.add('item');
          container.appendChild(div);
          
          const divValue = document.createElement('div');
          divValue.classList.add('divValue');
          divValue.textContent = aryNum[i];
          aryDiv.push(divValue);
          div.appendChild(divValue);
          
          const divIndex = document.createElement('div');
          divIndex.classList.add('divIndex');
          divIndex.textContent = i;
          div.appendChild(divIndex);
        }
        
        return aryDiv;
      }
      
      
      
      
      // 挿入ソートの関数
      function insertSort(arr) {
        const process = [arr.slice()]; // ソートの途中経過を保存
        let compareCount = 0;
        let swapCount = 0;

        for (let i = 1; i < arr.length; i++) {
          const key = arr[i];
          let j = i - 1;
          let swapped = false;  // 交換があったかを記録

          while (j >= 0 && arr[j] > key) {
            compareCount++;
            arr[j + 1] = arr[j];
            j--;
            swapCount++;
            swapped = true;  // 交換があったことを記録
          }
          arr[j + 1] = key;
          if (j >= 0) {
            compareCount++;
          }

          // 交換があった場合にのみ、配列の状態を保存
          if (swapped) {
            process.push(arr.slice()); // 途中経過を保存
          }
        }
        return { process, compareCount, swapCount };
      }
      
      // テーブルを更新する関数
      function updateTable(process, questionNumber, sortName) {
        const arr = process[0];
        
        
        // 問題文の更新
        const questionSentence = document.getElementById("question-sentence-" + questionNumber);
        questionSentence.innerHTML = `次の表は、配列<tt>arr = [${arr}]</tt>を${sortName}によって昇順に並び替える過程を表している。表中の空欄に適する数字を答えなさい。`;

        // テーブルのクリア
        const sortTable = document.getElementById("sort-table-" + questionNumber);
        sortTable.innerHTML = "";

        // テーブルヘッドの作成
        const thead = document.createElement("thead");
        const tableHeader = document.createElement("tr");
        const thInitial = document.createElement("th");
        thInitial.innerHTML = "＼";
        tableHeader.appendChild(thInitial);

        // 配列のインデックスをヘッダーに追加
        arr.forEach((_, i) => {
          const th = document.createElement("th");
          th.innerHTML = `<tt>${i}</tt>`;
          tableHeader.appendChild(th);
        });

        thead.appendChild(tableHeader);
        sortTable.appendChild(thead);

        // テーブルボディの作成
        const tbody = document.createElement("tbody");

        process.forEach((step, i) => {
          const row = document.createElement("tr");
          const stepTitle = document.createElement("th");

          if (i === 0) {
            stepTitle.innerText = "初期値";
          } else {
            stepTitle.innerText = `${i}回目`;
          }

          row.appendChild(stepTitle);

          // 配列の値を行に追加
          step.forEach(value => {
            const td = document.createElement("td");
            if (i === 0 || i === process.length - 1) {
              td.innerText = value;
            } else {
              td.className = "transparent clickable";
              td.innerText = value;
            }
            row.appendChild(td);
          });

          tbody.appendChild(row);
        });

        sortTable.appendChild(tbody);
      }
      
      // 初期化
      function question_initialize(){
        updateTable(createQuestionArray([9,7,3,5,1]), "q1", "挿入ソート");
        updateTable(createQuestionArray([5,3,0,1,4,2]), "q2", "挿入ソート");
        updateTable(createQuestionRandomArray(7, 7), "q3", "挿入ソート");
        updateTable(createQuestionRandomArray(10, 10), "q4", "挿入ソート");
      }
      
      // 配列を受け取ってプロセスを返す
      function createQuestionArray(arr) {
        const result = insertSort(arr.slice());   // ソート方法
        return result.process;
      }
      
      // 配列の長さとプロセス数の下限値を指定してプロセスを返す
      function createQuestionRandomArray(arrLength, minSwapTimes) {
        const arr = Array.from({length: arrLength}, (_, i) => i);
        
        let process = []; // 初期化（空の配列として宣言）
        let compareCount = 0;
        let swapCount = 0;
        
        for(let i = 0; i < 500; i++){
          shuffleArray(arr);
          
          const result = insertSort(arr.slice());   // ソート方法
          process = result.process;

          if(process.length >= minSwapTimes){
            return process;
          }
        }
      }
      
      function shuffleArray(ary) {
        for (let i = (ary.length - 1); 0 < i; i--) {
          let r = Math.floor(Math.random() * (i + 1));
          [ary[i], ary[r]] = [ary[r], ary[i]];
        }
        return ary;
      }
    </script>
  
</body>
</html>

